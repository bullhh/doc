# About support Emulated Interrupt Controller in ArceOS-hypervisor

## Interrupt Controllers

* x86_64: local Apic (xAPIC and x2APIC) and IO Apic
* aarch64: GIC (v2,v3,v4)
* riscv64: PLIC or APLIC

## Currently solution for the emulation of interrupt controller in ArceOS-hypervisor

None.

We just passthrough local Apic (X2APIC) to guest Linux in our previous version.

Emulated Interrupt Controller is necessery due to isolation and fucntion (virtual interrupt and CPU sharing) concern.

## References that may be useful

arch specific manuals:

* Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volum 3C: CHAPTER 30 APIC VIRTUALIZATION AND VIRTUAL INTERRUPTS
* [ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification](https://developer.arm.com/documentation/ihi0048/latest/)
* [Arm Generic Interrupt Controller (GIC) Architecture Specification GIC architecture version 3 and version 4](https://developer.arm.com/documentation/ihi0069/latest/)
* https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc


## What do we need to consider to support the emulation of interrupt controller?

First of all, arceos-hypervisor should pay attention to its irq handling routine.
Generally speaking, for interrupts generated by real hardware, 
except for the interrupts that are pass-through to the guest VM, 
other interrupts need to be processed by arceos-hypervisor 
and selectively injected into the guest VM through methods like `vcpu.irq_inject(irq_no)`.


Secondly, since interrupt are more like a per-vcpu device, 
in my opinion, 
supporting the emulated interrupt controller mainly involves modifications of `AxVcpu` structure.
 

* Each Vcpu should have a field to store pending interrupts, these irqs are waiting for being injected to VM at a proper time, e.g. before `vcpu.run()`. So, vcpu should provide a method like `vcpu.push_pending_irq()`



* We need to add arch specific fields in `AxVcpu` structure to maintain interrupt state, which can be called `InterruptContext`.
As a code segment copied from rtshyper as a example, `GicState` manages irq status for each vCPU.

    ```Rust
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct GicState {
        hcr: u32,
        eisr: [u32; GIC_LIST_REGS_NUM / 32],
        elrsr: [u32; GIC_LIST_REGS_NUM / 32],
        apr: u32,
        lr: [u32; GIC_LIST_REGS_NUM],
        pub ctlr: u32,
    }
    ```


